make ".turtles array 1000
buryname ".turtles
make ".curturtle 1
buryname ".curturtle

;; turtle bookkeeping

to saveturtlestate
  .setitem turtle :.turtles turtlestate
end

to markturtle
  .setitem turtle :.turtles "current
end

to checkturtle :ttl
  if emptyp item :ttl :.turtles [(throw "error se [no such turtle] :ttl)]
end

;; turtle queries

to turtle
  op :.curturtle
end

to turtlepos :ttl
  checkturtle :ttl
  if :ttl = turtle [op pos]
  op first item :ttl :.turtles
end

to turtlestate
  op (list pos heading pen)
end

;; changing turtles

to setturtle :ttl
  if :ttl = turtle [stop]
  checkturtle :ttl
  saveturtlestate
  make ".curturtle :ttl
  setturtlestate item :ttl :.turtles
  markturtle
end

to setturtlestate :ttl
  pu
  setpos first :ttl
  setheading first bf :ttl
  setpen last :ttl
end

;; creating and deleting turtles

to copyturtle
  localmake "oldturtle turtle
  saveturtlestate
  repeat 1000 [
    make ".curturtle :.curturtle + 1
    if :.curturtle > 1000 [make ".curturtle 1]
    if emptyp item turtle :.turtles [markturtle op :oldturtle]
  ]
  (throw "error [too many turtles])
end

to deleteturtle :ttl
  if :ttl = turtle [(throw "error [cannot delete current turtle])]
  .setitem :ttl :.turtles []
end

to resetturtles
  make ".turtles array 1000
  make ".curturtle 1
  markturtle
end

;; nice shorthands

to spread :count
  repeat :count [ignore copyturtle rt 360 / :count]
end

to allturtles
  op filter [not emptyp item ? :.turtles] iseq 1 1000
end

to alldo :.prog
  foreach allturtles [setturtle ? run :.prog]
end

